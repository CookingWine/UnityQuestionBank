### GC的概念

- C#内部有两个内存管理池:堆内存和栈内存。栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。C#中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在栈内存上，要么处于堆内存上。

- 只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态

- 一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。不再使用的内存只会在GC的时候才会被回收。

- 垃圾回收主要是指堆上的内存分配和回收，C#中会定时对堆内存进行GC操作。

### GC触发时机

- 在堆内存上进行内存分配操作，而内存不够的时候都会触发垃圾回收来利用闲置的内存;

- GC会自动的触发，不同平台运行频率不—样;
  
- GC可以被强制执行。
  
### 如何避免GC

- 减少临时变量的使用，多使用公共对象，多利用缓存机制。（将容器定义到函数外，用到容器的时候进行修改即可）
  
- 减少new对象的次数。
  
- 对于大量字符串拼接时，将StringBuilder代替String。（string不可修改性，修改即创建一个新的string对象，旧的直接抛弃等待GC，但少量字符串拼接用string，性能优于stringbuilder）

- 使用扩容的容器时，例如：List，StringBuilder等，定义时尽量根据存储变量的内存大小定义储存空间，减少扩容的操作。（扩容后，旧的容器直接抛弃等待GC）

- 代码逻辑优化：例如计时器当大于1s后才进行文本修改，而不是每帧都修改，或者禁止在关键时候GC，影响游戏性能，可以在加载页面或者进度条的时候GC。

- 利用对象池：对象池是一种Unity经常用到的内存管理服务，针对经常消失生成的对象，例如子弹，怪物等，作用在于减少创建每个对象的系统开销。在我们想要对象消除时，不直接Destory，而是隐藏起来SetActive（false），放入池子中，当需要再次显示一个新的对象时，先去池子中看有没有隐藏对象，有就取出来（显示） SetActive（true），没有的话，再实例化。

- 减少装箱拆箱( 装箱是将值类型转换为 object 类型或由此值类型实现的任何接口类型的过程)的操作

- 协程： yeild return 0 会产生装箱拆箱，可以替换为 yeild return null。
